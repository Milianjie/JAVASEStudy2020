package c实现线程的方式;

/*
 * 【实现线程的第一种方式】
 * 			编写一个类，直接继承java.lang.Thread，然后重写run()方法
 * 		创建线程对象：直接new
 * 		启动线程：调用线程对象的start()方法
 * 		start()方法的作用是：启动一个分支线程，在JVM中开辟一块新的栈空间。任务完成，瞬间结束，往后代码开始执行，只不过
 * 						分支线程也在同一时间执行，与主线程一同执行，互不干扰，以下程序执行结果如下：
													主线程-->0
													分支线程-->0
													分支线程-->1
													分支线程-->2
													分支线程-->3
													分支线程-->4
													主线程-->1
													分支线程-->5
													分支线程-->6
													分支线程-->7
													分支线程-->8
													主线程-->2
													分支线程-->9
													主线程-->3
													主线程-->4
													主线程-->5
													主线程-->6
													主线程-->7
													主线程-->8
													主线程-->9
					从输出我们可以看到，输出结果主线程与分支线程的方法输出是杂乱的，说明是两个线程中的方法同一时间在执行。
			但需要注意的是start()方法的任务是开辟新的栈空间，新的栈空间被开辟，该方法就结束了。线程也就启动成功了
			线程启动成功就会自动调用run()方法，并且run方法在分支栈的栈底部（压栈）
			main方法也在主栈的栈底部，所以两个方法是平级的，唯一的区别只是分支线程启动代码在主栈中，main方法压栈执行后
			分支线程才能启动。
			
 * 
 */

public class ThreadTest01 {
	
	public static void main(String[] args) {
		
		//这里是main方法，这里的代码属于主线程，在主栈中运行
		//新建一个分支线程对象
		MyThread1 myThread = new MyThread1();
		
		//这种调用还是单线程，不会开辟新的分支栈空间
		//myThread.run();
		
		//启动线程
		myThread.start();
		
		//这里的代码还是运行在主线程中
		for(int i = 0;i < 10;i++) {
			System.out.println("主线程-->"+i);
		}
		
	}

}

class MyThread1 extends Thread{
	
	@Override
	public void run() {
		// TODO 自动生成的方法存根
		for(int i = 0 ; i < 10 ;i++) {
			System.out.println("分支线程-->"+i);
		}
	}
	
}