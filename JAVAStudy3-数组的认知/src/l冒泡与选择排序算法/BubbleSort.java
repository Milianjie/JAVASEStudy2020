package l冒泡与选择排序算法;

/**
 * 					冒泡排序算法：
 * 							原始数据：{3,2,7,6,9,1}
 * 				第一次循环（最大的跑到最右边）：
 * 					3和2比较,3>2,所以3和2交换位置：2,3,7,6,9,1
 * 					3和7比较，虽然不需要交换位置，但还是的比较一次：2,3,7,6,9,1
 * 					7和6交换位置：2,3,6,7,9,1
 * 					7和9不交换位置：2,3,6,7,9,1
 * 					9和1交换位置：2,3,6,7,1,9
 * 			经过第一次循环，此时剩下参与比较的数据为：2,3,6,7,1 第二次循环如下
 *					2和3比较：2,3,6,7,1 
 * 					3和6比较：2,3,6,7,1
 * 					6和7比较：2,3,6,7,1
 * 					7和1比较：2,3,6,1,7
 * 			经过第二次循环剩下参与比较数据为：2,3,6,1 第三次循环如下
 * 					2和3比较：2,3,6,1
 * 					3和6比较：2,3,6,1
 * 					6和1比较：2,3,1,6
 * 			剩下参与为：2,3,1 第四次循环如下
 * 					2和3比较：2,3,1
 * 					3和1比较：2,1,3
 * 			第四循环后剩下：2,1，第五次循环如下
 * 					2和2比较：1,2
 * 
 * 			1、每一次循环结束之后，都要找出最大的数据，将其放到参与比较的这堆数据的最右边，即冒出最大的气泡
 * 			2、其核心是:拿着左边的数据和右边的数据进行比较，左边大于右边时，交换位置
 * 				数据6个比较5次
 * 				数据5个比较4次
 * 				数据4个比较3次
 * 				数据3个比较2次
 * 				数据2个比较1次
 * 			所以说要两个循环嵌套，第一次循环比较数组长度减1次，所以内循环中的变量j要小于一个逐减的变量
 * 			才能在逐次的循环中其比较的次数一次次的减少，所以可以设定外循环变量i=array.length-1,然后i--
 * 			则内循环的变量小于i，j++;当i=6时，数组中6个数据，通过内循环比较5次，然后i--，再通过内循环
 * 			比较4次，依次类推，就满足了一个冒泡排序
 * 			
 * 
 * @author 钟荣杰
 *
 */

public class BubbleSort {
	
	public static void main(String[] args) {
		
		int[] array = {3,2,7,6,9,1};
		
		
		/*自己写的失败的作品
		int index = 1;
		//冒泡排序算法
		for (int i = 0; i < array.length-1; i++) {
			if (array[i]<array[index]) {
				index++;
			}else {
				int c =array[i];
				array[i] = array[index];
				array[index] =c;
				index++;	
			}	
		}*/
		
		int count1 = 0;
		int count2 = 0;
		
		//冒泡排序算法
		for (int i = array.length-1; i > 0 ; i--) {
			count1++;
			for (int j = 0; j < i; j++) {
				//通过左边与右边比较，左大于右，交换位置，否者不写任何修改，相比上面自己多写的一个else可清晰多了
				if (array[j] > array[j+1]) {
					int temp ;//定义一个临时的交换变量
					temp = array[j];
					array[j] = array[i];
					array[i] = temp;
					
			}
				count2++;
			
		}
		
	}
		System.out.println("循环的次数 count1 = "+count1);
		System.out.println("比较的次数 count2 = "+count2);
		
		for (int i = 0; i < array.length; i++) {
			int j = array[i];
			System.out.print(j+" ");
		}
		
	}

}
